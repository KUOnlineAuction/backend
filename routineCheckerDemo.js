const cron = require("node-cron");
const dotenv = require("dotenv");
const mongoose = require("mongoose");
const Auction = require("./models/auctionModel");
const { BillingInfo } = require("./models/billingInfoModel");
const Report = require("./models/reportModel");
const User = require("./models/userModel");
const BidHistory = require("./models/bidHistoryModel");
const gernerateBadge = require("./utils/badge");
const Refund = require("./models/refundModel");

dotenv.config({ path: "./config.env" });
const DB = process.env.DATABASE.replace(
  "<PASSWORD>",
  process.env.DATABASE_PASSWORD
);

const autogeneratedUserID = "632be28f8d9b6b2337772296";
const bidderPaymentDeadlineLength = 3;

mongoose
  .connect(DB, {
    useNewUrlParser: true,
    useCreateIndex: true,
    useFindAndModify: false,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("DB connection successful");
  });

let hourlyCheckList = []
let hourlyCheckListFive = []

async function getAuctionThisHour() {
    const auctions = await Auction.aggregate([
      {
          $match: {
              endDate: {$lt :(new Date(Date.now() + 360000))},
              auctionStatus: "bidding"
          }
      },
      {
          $project: {
              _id: 1,
              endDate: 1,
          }
      },
      {
          $sort: { endDate: 1}
      }
    ])
    hourlyCheckList.length = 0
    hourlyCheckList.push.apply(hourlyCheckList, auctions)
    hourlyCheckListFive.length = 0
    hourlyCheckListFive.push.apply(hourlyCheckListFive, auctions)
    console.log(`[M: DEMO minutely Checklist] Found ${hourlyCheckList.length} auctions ending this hour.`)
}
getAuctionThisHour()
// optimized Routine checking for Auctions ending:
//      1) Pulling auctions (Once an hour)
cron.schedule("* * * * *", getAuctionThisHour)
// }

// test();

//   2) Update the ending auctions (Once a minute)
cron.schedule("* * * * *", async() => {
    // check if there is an auction ending this hour
    if(hourlyCheckList.length === 0){
        console.log(`[M: End Auctions] No entry updated sinc enone end this hour.`)
        return;
    }

    let cont = true
    let editedEntries = 0

    // continue updating status as long as the first entry in queue is ending that minute
    while(cont){
        if (hourlyCheckList.length == 0){
            cont = false
            break
        }
        const checkingAuction = hourlyCheckList[0]
    
        // update the first entry of the list
        if(checkingAuction.endDate < Date.now()){
            // find the entry
            const updatedAuction = await Auction.findById(checkingAuction._id)
            // if there is no bidder
            if(!updatedAuction.currentWinnerID){
                // change the bidding to "finished"
                updatedAuction.auctionStatus = "finished"
                const newBillingInfo = {
                  auctionID: updatedAuction._id,
                  winningPrice: updatedAuction.currentPrice,
                  billingInfoStatus: "failed",
                  failureCause: "noBidders"
                }
                createdBillingInfo = await BillingInfo.create(newBillingInfo);
                updatedAuction.billingHistoryID = createdBillingInfo._id
                await updatedAuction.save({ validateBeforeSave: false })
            }
            
            // else change the bidding to "waiting"
            else {
                updatedAuction.auctionStatus = "waiting"
                // Add an billing info
                const newBillingInfo = {
                    auctionID: updatedAuction._id,
                    winningPrice: updatedAuction.currentPrice,
                    bidderPaymentDeadline: Date.now() + bidderPaymentDeadlineLength * 1000 * 60 * 60 * 24,
                }
                createdBillingInfo = await BillingInfo.create(newBillingInfo);
                updatedAuction.billingHistoryID = createdBillingInfo._id
                await updatedAuction.save({ validateBeforeSave: false })
                await User.findByIdAndUpdate(updatedAuction.auctioneerID, {
                  $push: {"billingList": createdBillingInfo._id}
                })
                await User.findByIdAndUpdate(updatedAuction.currentWinnerID, {
                  $push: {"billingList": createdBillingInfo._id}
                })
                // remove from active bidding list for user

                const userFilter = {
                    activeBiddingList: mongoose.Types.ObjectId(updatedAuction._id)
                }
                const updateActiveBiddingList = {
                    $pull: {"activeBiddingList": updatedAuction._id},
                }
                await User.updateMany(userFilter,updateActiveBiddingList)

                // BUT add it to finished bidding list for winner
                const winnerFilter = {
                    _id: updatedAuction.currentWinnerID
                }
                const updateWinnerFinishedAuctionList = {
                    $push: {"finishedBiddingList": updatedAuction._id}
                }
                await User.updateOne(winnerFilter, updateWinnerFinishedAuctionList)
            }
            // remove from active auction list of the auctioneer for any case 
            const auctioneerFilter = {
              _id: updatedAuction.auctioneerID
            }
            const updateActiveAuctionList = {
              $pull: {"activeAuctionList": updatedAuction._id},
              $push: {"finishedAuctionList": updatedAuction._id}
            }
            await User.updateOne(auctioneerFilter, updateActiveAuctionList)
            
            // remove this auction from any "following list" anyways
            editedEntries++
            hourlyCheckList.shift()
        } else {
            cont = false
        }
    }
    if(editedEntries > 0){
      await gernerateBadge();
    }
    console.log(`[M: End Auctions] ${editedEntries} auctions changed to waiting/finished.`)
})

// UNOPTIMIZED Routine checking for Auctions ending (Every start of a minute) 
// cron.schedule("* * * * *", async () => {
//   const filter = {
//     endDate: { $lt: Date.now() },
//     auctionStatus: "bidding",
//   };
//   const update = {
//     auctionStatus: "waiting",
//   };

//   const auction = await Auction.updateMany(filter, update);
//   console.log(`Found ${auction.n} documents, updated ${auction.nModified}`);
//   // console.log(auction)
// });

// Routine Checking for bidder payment deadline (Every day at midnight)
// Act as the auction never happens in the first place and add an error message and status to auction
cron.schedule("0 0 * * *", async () => {
// const test = async () => {
  const filter = {
    bidderPaymentDeadline: { $lt: Date.now() },
    billingInfoStatus: "waitingForPayment"
  };
  const billingFound = await BillingInfo.find(filter);
  for(el of billingFound){
    // set billing info to failed
    el.billingInfoStatus = "failed";
    el.failureCause = "biddderPaymentDeadlineBroken";
    await el.save();

    const auction = await Auction.findById(el.auctionID);

    let report = {
      reporterID: autogeneratedUserID,
      reportedID: auction.currentWinnerID,
      description:
        "[Autogenerated Report] This user has past the deadline of payment for an auctioned item.",
    };
    const newReport = await Report.create(report);
  }
  console.log(`[D:Bidder Payment Deadline] : Found ${billingFound.length} user with overdue deadline on payment. Generated ${billingFound.length} report(s).`)
// }
})
// test();

// // Routine checking for delivering deadline (Every day at midnight)
// const test = async () => {
cron.schedule("0 0 * * *", async () => {
  const filter = {
    deliverDeadline: { $lt: Date.now() },
    billingInfoStatus: "waitingForShipping",
    deliverDeadlineBroken: false,
  };
  const update = {
    billingInfoStatus: "failed",
    failureCause: "auctioneerShippingDeadlineBroken",
    deliverDeadlineBroken: true
  };
  const billingsFound = await BillingInfo.aggregate([
    {
      $match: {
        deliverDeadline: { $lt: new Date() },
        billingInfoStatus: "waitingForShipping",
        deliverDeadlineBroken: false,
      },
    },
    {
      $lookup: {
        from: "auctions",
        localField: "auctionID",
        foreignField: "_id",
        as: "involvedAuction",
      },
    },
    {
      $set: {
        auctioneerID: { $arrayElemAt: ["$involvedAuction.auctioneerID", 0] },
      },
    },
  ]);
  for (let el of billingsFound) {
    // console.log(el)
    let report = {
      reporterID: autogeneratedUserID,
      reportedID: el.auctioneerID,
      description:
        "[Autogenerated Report] This user has past the deadline of sending the delivery info.",
    };
    const newReport = await Report.create(report);

    // create refund document
    let refund = {
      refundeeID: mongoose.Types.ObjectId(el.currentWinnerID),
      refundAmount: el.slip.slipAmount,
      refundStatus: false,
      dateCreated: Date.now()
    }
    const createdRefund = await Refund.create(refund);

    const auctionnerUpdate = await User.find(el.auctioneerID);
    auctionnerUpdate.totalAuction = auctionnerUpdate.totalAuction + 1;
    await auctionnerUpdate.save();
  }
  const billingsUpdate = await BillingInfo.updateMany(filter, update);
  console.log(
    `[D: Delivery Deadline] Found ${billingsUpdate.n} auctions past deliver deadline, Generated ${billingsUpdate.n} reports.`
  );
// }
});
// test();

// // Routine checking for confirm item recieve deadline (Every day at midnight)
cron.schedule("0 0 * * *", async () => {
  const filter = {
    confirmItemRecieveDeadline: { $lt: new Date() },
    billingInfoStatus: "waitingForConfirm",
  };
  const update = {
    billingInfoStatus: "waitingAdminPayment",
  };
  const billingsUpdate = await BillingInfo.updateMany(filter, update);
  console.log(
    `[D: Recieve Deadline] Found ${billingsUpdate.n} auctions past item recieved confirmation deadline, Auto completed ${billingsUpdate.n} auctions.`
  );
});

// Routine checking for auto-destroy auctions (Every day?)
cron.schedule("0 0 * * *", async () => {
// const destroyer = async ()=>{
  const filter = {
    autoDestroy: { $lt: new Date() },
  };
  const documentDestroyingList = await Auction.find(filter, '_id')
  for (el of documentDestroyingList){
    const documentDestroying = await Auction.findById(el._id)
    // console.log(documentDestroying.billingHistoryID)
    // console.log(typeof documentDestroying.billingHistoryID)  

    // remove the document from finishedBiddingList, finishedAuctionList
    const finishedBiddingListFilter = {
      finishedBiddingList: mongoose.Types.ObjectId(documentDestroying._id)
    }

    const finishedAuctionListFilter = {
      finishedAuctionList: mongoose.Types.ObjectId(documentDestroying._id)
    }

    const finishedBiddingListUpdate = {
      $pull : {finishedBiddingList: mongoose.Types.ObjectId(documentDestroying._id)}
    }

    const finishedAuctionListUpdate = {
      $pull : {finishedAuctionList: mongoose.Types.ObjectId(documentDestroying._id)}
    }

    await User.updateMany(finishedBiddingListFilter, finishedBiddingListUpdate)
    await User.updateMany(finishedAuctionListFilter, finishedAuctionListUpdate)

    // remove the corresponded billing info
    await BillingInfo.findByIdAndDelete(documentDestroying.billingHistoryID)

    // remove all the bid history
    const deleteBidHistoryFilter = {
      _id: {$in: documentDestroying.bidHistory}
    }
    await BidHistory.deleteMany(deleteBidHistoryFilter)

    // finally remove the auction
    await Auction.findByIdAndDelete(documentDestroying._id)
  }
  console.log(`[D: auto destroy] Deleted ${documentDestroyingList.length} auctions`)
});

// follow list remover
cron.schedule("* * * * *", async () => {
  if(hourlyCheckListFive.length === 0){
    console.log(`[M: Follow remove 5 minute] No entry updated since none end this hour.`)
    return;
  }
  let cont = true
  let count = 0
  while(cont){
    if (hourlyCheckListFive.length == 0){
      cont = false
      break
  }
  const checkingAuction = hourlyCheckListFive[0]

  // update the first entry of the list
    if(checkingAuction.endDate < (Date.now() + 5 * 60 * 1000 + 1 )){
      const updateQuery = {
        followingList: mongoose.Types.ObjectId(checkingAuction._id)
      }
      const updateField = {
        $pull: {"followingList": checkingAuction._id}
      }
      await User.updateMany(updateQuery, updateField)
      hourlyCheckListFive.shift()
      count++
    } else {
      cont = false
    } 
  }
  console.log(`[M: Follow remove 5 minute] ${count} entries remove from user(s) follow list.`)
})